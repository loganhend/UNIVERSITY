#include "array2.h"
ifstream in("input.txt");
ofstream out("output.txt");

void checker(int n, array2& arr1)//функци€ дл€ проверки\поиска
{
	if (arr1.search(n))//если в двумерном массиве arr1 найден элемент n
	{
		out << "Ёлемент " << n << " найден\n";//в поток вывода пишем:
	}
	else//если в двумерном массиве arr1 не найден элемент n
		out << "Ёлемент " << n << " не найден\n";//в поток вывода пишем:
	out << '\n';
}
int main()
{
	array2 arr1, arr2;//создаем два двумерных массива
	in >> arr1 >> arr2;//заполн€ем их из потока ввода (перегрузка оператора прописана в библиотеке)
	out << "Arr 1:\n" << arr1 << '\n' << "Arr 2:\n" << arr2 << '\n';//в поток выводим массивы
	arr1.sort2(); arr2.sort2();//производим сортировку обоих массивов
	out << "Arr 1:\n" << arr1 << '\n' << "Arr 2:\n" << arr2 << '\n';//в поток выводим массивы

	vector<int> a;
	for (int i = 0; i < arr1.size_w(); i++)//количество элементов дл€ считывани€ равно количеству столбцов
	{
		int k;
		in >> k;//считываем элемент k из потока
		a.push_back(k);//добавл€ем элемент в вектор
	}
	arr1.insert(a);//выполн€ем операцию добавлени€ элментов в массив
	out << "Arr 1:\n" << arr1 << '\n';//в поток выводим массив
	for (int i = 0; i < 3; i++)
	{
		int n; in >> n;// принимаем из потока значени€ n дл€ проверки
		checker(n, arr1);//эти значени€ прогон€ем через функцию проверки
	}



	vector<int> uni = Union(arr1, arr2);//создаем вектор uni и в него задаем результат операции объединени€
	out << "ќбъединение: ";
	for (int i = 0; i < uni.size(); i++)
	{
		out << uni[i] << ' ';//в поток вывода записываем результат операции
	}
	out << "\n\n";
	vector<int> inter = Intersection(arr1, arr2);//создаем вектор inter и в него задаем результат операции пересечени€
	out << "ѕересечение: ";
	for (int i = 0; i < inter.size(); i++)
	{
		out << inter[i] << ' ';//в поток вывода записываем результат операции
	}
	return 0;
}